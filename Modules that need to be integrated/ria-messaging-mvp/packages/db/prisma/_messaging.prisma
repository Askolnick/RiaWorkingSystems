// Omnichannel Messaging MVP

enum ConversationKind { internal external email social }
enum ConversationStatus { open snoozed closed }
enum Priority { low normal high urgent }

model Inbox {
  id        String   @id @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  slug      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  conversations Conversation[]

  @@unique([tenantId, slug])
  @@index([tenantId, name])
}

model Conversation {
  id          String            @id @db.Uuid
  tenantId    String            @db.Uuid
  inboxId     String?           @db.Uuid
  kind        ConversationKind
  subject     String?
  status      ConversationStatus @default(open)
  priority    Priority          @default(normal)
  assigneeId  String?           @db.Uuid
  tags        String[]          @db.Text
  lastAt      DateTime          @default(now())
  createdAt   DateTime          @default(now())

  inbox      Inbox?     @relation(fields: [inboxId], references: [id], onDelete: SetNull)
  messages   Message[]
  participants ConversationParticipant[]

  @@index([tenantId, lastAt])
  @@index([tenantId, status, priority])
  @@index([tenantId, assigneeId])
}

model ConversationParticipant {
  id             String   @id @db.Uuid
  tenantId       String   @db.Uuid
  conversationId String   @db.Uuid
  userId         String?  @db.Uuid     // internal user (nullable for externals)
  externalName   String?
  externalAddr   String?               // email/handle/phone
  role           String?               // 'member' | 'requester' | ...

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([tenantId, conversationId])
}

enum MessageSource { internal email slack social sms }
enum MessageDirection { in out }

model Message {
  id             String          @id @db.Uuid
  tenantId       String          @db.Uuid
  conversationId String          @db.Uuid
  source         MessageSource
  direction      MessageDirection
  authorId       String?         @db.Uuid
  authorAddr     String?
  bodyText       String
  bodyHtml       String?
  sentAt         DateTime        @default(now())
  externalId     String?         // provider message id
  inReplyToId    String?         // provider thread id
  metadata       Json?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([tenantId, conversationId, sentAt])
  @@index([tenantId, source])
}

model Template {
  id        String   @id @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  channel   String   // 'email'|'chat'|'social'
  subject   String?
  bodyMd    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, name, channel])
  @@index([tenantId, channel])
}

model RoutingRule {
  id        String   @id @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  enabled   Boolean  @default(true)
  // simple JSON predicate for MVP: { "source":"email", "contains":"billing" }
  predicate Json
  // action: { "inbox":"support", "assignTo":"userId", "addTags":["billing"] }
  action    Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, enabled])
}
