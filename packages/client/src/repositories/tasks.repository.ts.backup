import { BaseRepository, MockRepository } from './base.repository';
import type { TaskStatus } from '@ria/web-ui';
import { generateRankBetween } from '@ria/tasks-server';
import type {
  TaskCustomField,
  TaskCustomFieldValue,
  CreateTaskCustomFieldData,
  UpdateTaskCustomFieldData,
  SetTaskCustomFieldValueData,
  TaskSavedView,
  CreateTaskSavedViewData,
  UpdateTaskSavedViewData
} from '@ria/tasks-server';

export interface Task {
  id: string;
  title: string;
  description?: string;
  status: TaskStatus;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  assigneeId?: string;
  dueAt?: string;
  rank?: string;
  tenantId: string;
  createdAt: string;
  updatedAt: string;
}

interface CreateTaskDTO {
  title: string;
  description?: string;
  status?: TaskStatus;
  priority?: Task['priority'];
  assigneeId?: string;
  dueAt?: string;
  rank?: string;
}

interface UpdateTaskDTO {
  title?: string;
  description?: string;
  status?: TaskStatus;
  priority?: Task['priority'];
  assigneeId?: string;
  dueAt?: string;
  rank?: string;
}

export class TasksRepository extends BaseRepository<Task, CreateTaskDTO, UpdateTaskDTO> {
  protected endpoint = '/tasks';

  async moveTask(id: string, newStatus: TaskStatus, beforeTaskId?: string, afterTaskId?: string): Promise<Task> {
    const data: UpdateTaskDTO = { status: newStatus };
    
    if (beforeTaskId || afterTaskId) {
      // Calculate new rank based on adjacent tasks
      const [beforeTask, afterTask] = await Promise.all([
        beforeTaskId ? this.findById(beforeTaskId) : Promise.resolve(undefined),
        afterTaskId ? this.findById(afterTaskId) : Promise.resolve(undefined),
      ]);
      
      data.rank = generateRankBetween(beforeTask?.rank, afterTask?.rank);
    }
    
    return this.update(id, data);
  }

  async getTasksByStatus(status: TaskStatus, params?: { tenantId?: string }): Promise<Task[]> {
    const filters = { status, ...(params?.tenantId && { tenantId: params.tenantId }) };
    const response = await this.findAll({ filters, sortBy: 'rank', sortOrder: 'asc' });
    return response.data;
  }

  async createDependency(predecessorId: string, successorId: string, type?: string, lagMinutes?: number): Promise<void> {
    await this.request('POST', '/dependencies', {
      predecessorId,
      successorId, 
      type: type || 'FS',
      lagMinutes: lagMinutes || 0
    });
  }

  async removeDependency(predecessorId: string, successorId: string): Promise<void> {
    await this.request('DELETE', `/dependencies/${predecessorId}/${successorId}`);
  }

  async getTaskDependencies(taskId: string): Promise<{ predecessors: any[], successors: any[] }> {
    return this.request('GET', `/dependencies/${taskId}`);
  }
}

export class MockTasksRepository extends MockRepository<Task, CreateTaskDTO, UpdateTaskDTO> {
  protected storageKey = 'ria_tasks';
  protected endpoint = '/tasks';

  private mockTasks: Task[] = [
    {
      id: '1',
      title: 'Update client portal UI',
      description: 'Modernize the dashboard interface with new design system',
      status: 'todo',
      priority: 'high',
      dueAt: '2024-10-15',
      rank: 'A',
      tenantId: 'demo-tenant',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: '2',
      title: 'Review Q3 performance reports',
      description: 'Analyze portfolio performance and prepare client summaries',
      status: 'todo',
      priority: 'normal',
      dueAt: '2024-10-20',
      rank: 'B',
      tenantId: 'demo-tenant',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: '3',
      title: 'Implement automated reporting',
      description: 'Set up scheduled report generation and email delivery',
      status: 'doing',
      priority: 'urgent',
      dueAt: '2024-10-12',
      rank: 'A',
      tenantId: 'demo-tenant',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: '4',
      title: 'Client onboarding process',
      description: 'Streamline new client setup and documentation workflow',
      status: 'blocked',
      priority: 'low',
      dueAt: '2024-10-25',
      rank: 'A',
      tenantId: 'demo-tenant',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    {
      id: '5',
      title: 'Setup task management system',
      description: 'Implement Kanban board for team workflow management',
      status: 'done',
      priority: 'normal',
      rank: 'A',
      tenantId: 'demo-tenant',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    }
  ];

  constructor() {
    super();
    // Initialize with mock data (only on client side)
    if (typeof window !== 'undefined' && this.getStorage().length === 0) {
      this.setStorage(this.mockTasks);
    }
  }

  async moveTask(id: string, newStatus: TaskStatus, beforeTaskId?: string, afterTaskId?: string): Promise<Task> {
    await this.simulateDelay();
    
    const tasks = this.getStorage();
    const taskIndex = tasks.findIndex(t => t.id === id);
    
    if (taskIndex === -1) {
      throw new Error('Task not found');
    }

    // Update status
    tasks[taskIndex] = { ...tasks[taskIndex], status: newStatus };

    // Calculate new rank if needed
    if (beforeTaskId || afterTaskId) {
      const beforeTask = beforeTaskId ? tasks.find(t => t.id === beforeTaskId) : undefined;
      const afterTask = afterTaskId ? tasks.find(t => t.id === afterTaskId) : undefined;
      
      tasks[taskIndex] = {
        ...tasks[taskIndex],
        rank: generateRankBetween(beforeTask?.rank, afterTask?.rank)
      };
    } else {
      // Generate rank based on other tasks in the same status
      const statusTasks = tasks
        .filter(t => t.status === newStatus && t.id !== id)
        .sort((a, b) => (b.rank || '').localeCompare(a.rank || ''));
      
      const lastTask = statusTasks[0];
      tasks[taskIndex] = {
        ...tasks[taskIndex],
        rank: generateRankBetween(lastTask?.rank)
      };
    }

    tasks[taskIndex] = {
      ...tasks[taskIndex],
      updatedAt: new Date().toISOString()
    };

    this.setStorage(tasks);
    return tasks[taskIndex];
  }

  async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
    await this.simulateDelay();
    
    const tasks = this.getStorage();
    return tasks
      .filter(t => t.status === status)
      .sort((a, b) => (a.rank || '').localeCompare(b.rank || ''));
  }

  private async simulateDelay(): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, 100));
  }

  // Mock task dependencies storage
  private mockDependencies: Array<{
    id: string;
    predecessorId: string;
    successorId: string;
    type: string;
    lagMinutes: number;
  }> = [];

  async createDependency(predecessorId: string, successorId: string, type?: string, lagMinutes?: number): Promise<void> {
    await this.simulateDelay();
    
    // Check for circular dependencies
    if (this.wouldCreateCircularDependency(predecessorId, successorId)) {
      throw new Error('Cannot create dependency: would create circular dependency');
    }

    const dependency = {
      id: `dep_${Date.now()}`,
      predecessorId,
      successorId,
      type: type || 'FS',
      lagMinutes: lagMinutes || 0
    };

    this.mockDependencies.push(dependency);
  }

  async removeDependency(predecessorId: string, successorId: string): Promise<void> {
    await this.simulateDelay();
    this.mockDependencies = this.mockDependencies.filter(
      dep => !(dep.predecessorId === predecessorId && dep.successorId === successorId)
    );
  }

  async getTaskDependencies(taskId: string): Promise<{ predecessors: any[], successors: any[] }> {
    await this.simulateDelay();
    
    const tasks = this.getStorage();
    const predecessors = this.mockDependencies
      .filter(dep => dep.successorId === taskId)
      .map(dep => ({
        ...dep,
        task: tasks.find(t => t.id === dep.predecessorId)
      }));

    const successors = this.mockDependencies
      .filter(dep => dep.predecessorId === taskId)
      .map(dep => ({
        ...dep,
        task: tasks.find(t => t.id === dep.successorId)
      }));

    return { predecessors, successors };
  }

  private wouldCreateCircularDependency(predecessorId: string, successorId: string): boolean {
    // Simple circular dependency check - in real implementation this would be more sophisticated
    const existingPath = this.mockDependencies.find(
      dep => dep.predecessorId === successorId && dep.successorId === predecessorId
    );
    return !!existingPath;
  }

  // Custom Fields Management
  private customFieldsStorageKey = 'ria_task_custom_fields';
  private customFieldValuesStorageKey = 'ria_task_custom_field_values';

  private mockCustomFields: Array<{
    id: string;
    tenantId: string;
    name: string;
    key: string;
    description?: string;
    type: string;
    required: boolean;
    defaultValue?: any;
    options?: any[];
    validation?: any;
    isActive: boolean;
    sortOrder: number;
    createdAt: string;
    updatedAt: string;
  }> = [
    {
      id: 'cf1',
      tenantId: 'demo-tenant',
      name: 'Story Points',
      key: 'story_points',
      description: 'Estimated complexity points for this task',
      type: 'number',
      required: false,
      defaultValue: 1,
      validation: { min: 1, max: 21 },
      isActive: true,
      sortOrder: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'cf2',
      tenantId: 'demo-tenant',
      name: 'Epic',
      key: 'epic',
      description: 'The epic this task belongs to',
      type: 'select',
      required: false,
      options: [
        { value: 'auth', label: 'Authentication System', color: '#3B82F6' },
        { value: 'dashboard', label: 'Dashboard Improvements', color: '#10B981' },
        { value: 'mobile', label: 'Mobile App', color: '#F59E0B' }
      ],
      isActive: true,
      sortOrder: 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'cf3',
      tenantId: 'demo-tenant',
      name: 'Customer Impact',
      key: 'customer_impact',
      description: 'Impact level on customers',
      type: 'select',
      required: true,
      options: [
        { value: 'low', label: 'Low Impact', color: '#6B7280' },
        { value: 'medium', label: 'Medium Impact', color: '#F59E0B' },
        { value: 'high', label: 'High Impact', color: '#EF4444' }
      ],
      isActive: true,
      sortOrder: 2,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
  ];

  private mockCustomFieldValues: Array<{
    id: string;
    tenantId: string;
    taskId: string;
    customFieldId: string;
    value: any;
    createdAt: string;
    updatedAt: string;
  }> = [
    {
      id: 'cfv1',
      tenantId: 'demo-tenant',
      taskId: '1',
      customFieldId: 'cf1',
      value: 5,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'cfv2',
      tenantId: 'demo-tenant',
      taskId: '1',
      customFieldId: 'cf2',
      value: 'auth',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'cfv3',
      tenantId: 'demo-tenant',
      taskId: '2',
      customFieldId: 'cf1',
      value: 3,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
  ];

  async getCustomFields(): Promise<TaskCustomField[]> {
    await this.simulateDelay();
    return this.mockCustomFields
      .filter(field => field.isActive)
      .sort((a, b) => a.sortOrder - b.sortOrder);
  }

  async createCustomField(data: CreateTaskCustomFieldData): Promise<TaskCustomField> {
    await this.simulateDelay();
    
    const newField = {
      id: `cf_${Date.now()}`,
      tenantId: 'demo-tenant',
      ...data,
      isActive: true,
      sortOrder: data.sortOrder ?? this.mockCustomFields.length,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    this.mockCustomFields.push(newField);
    return newField;
  }

  async updateCustomField(id: string, data: UpdateTaskCustomFieldData): Promise<TaskCustomField> {
    await this.simulateDelay();
    
    const index = this.mockCustomFields.findIndex(field => field.id === id);
    if (index === -1) {
      throw new Error('Custom field not found');
    }

    this.mockCustomFields[index] = {
      ...this.mockCustomFields[index],
      ...data,
      updatedAt: new Date().toISOString()
    };

    return this.mockCustomFields[index];
  }

  async deleteCustomField(id: string): Promise<void> {
    await this.simulateDelay();
    
    // Mark as inactive instead of deleting to preserve data integrity
    const index = this.mockCustomFields.findIndex(field => field.id === id);
    if (index !== -1) {
      this.mockCustomFields[index].isActive = false;
      this.mockCustomFields[index].updatedAt = new Date().toISOString();
    }
  }

  async getTaskCustomFieldValues(taskId: string): Promise<TaskCustomFieldValue[]> {
    await this.simulateDelay();
    
    const values = this.mockCustomFieldValues.filter(value => value.taskId === taskId);
    
    return values.map(value => ({
      ...value,
      customField: this.mockCustomFields.find(field => field.id === value.customFieldId)
    }));
  }

  async setTaskCustomFieldValue(taskId: string, customFieldId: string, value: any): Promise<void> {
    await this.simulateDelay();
    
    const existingIndex = this.mockCustomFieldValues.findIndex(
      val => val.taskId === taskId && val.customFieldId === customFieldId
    );

    if (existingIndex !== -1) {
      // Update existing value
      this.mockCustomFieldValues[existingIndex] = {
        ...this.mockCustomFieldValues[existingIndex],
        value,
        updatedAt: new Date().toISOString()
      };
    } else {
      // Create new value
      const newValue = {
        id: `cfv_${Date.now()}`,
        tenantId: 'demo-tenant',
        taskId,
        customFieldId,
        value,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      this.mockCustomFieldValues.push(newValue);
    }
  }

  async removeTaskCustomFieldValue(taskId: string, customFieldId: string): Promise<void> {
    await this.simulateDelay();
    
    this.mockCustomFieldValues = this.mockCustomFieldValues.filter(
      val => !(val.taskId === taskId && val.customFieldId === customFieldId)
    );
  }

  // -------------------- Saved Views --------------------
  
  private mockSavedViews: TaskSavedView[] = [
    {
      id: 'view-1',
      tenantId: 'tenant-1',
      name: 'My Tasks',
      description: 'Tasks assigned to me',
      viewType: 'list',
      filters: {
        assigneeId: ['current-user']
      },
      sorting: [
        { field: 'priority', direction: 'desc' },
        { field: 'dueAt', direction: 'asc' }
      ],
      isDefault: true,
      isShared: false,
      createdBy: 'user-1',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'view-2',
      tenantId: 'tenant-1',
      name: 'Overdue Tasks',
      description: 'Tasks that are past their due date',
      viewType: 'list',
      filters: {
        dueDateRange: {
          end: new Date().toISOString()
        }
      },
      sorting: [
        { field: 'dueAt', direction: 'asc' }
      ],
      isDefault: false,
      isShared: true,
      createdBy: 'user-1',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: 'view-3',
      tenantId: 'tenant-1',
      name: 'Board View',
      description: 'Kanban board for all tasks',
      viewType: 'board',
      filters: {},
      sorting: [
        { field: 'rank', direction: 'asc' }
      ],
      groupBy: 'status',
      isDefault: false,
      isShared: false,
      createdBy: 'user-1',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
  ];

  async getSavedViews(): Promise<TaskSavedView[]> {
    await this.simulateDelay();
    return [...this.mockSavedViews];
  }

  async getSavedView(id: string): Promise<TaskSavedView | null> {
    await this.simulateDelay();
    return this.mockSavedViews.find(view => view.id === id) || null;
  }

  async createSavedView(data: CreateTaskSavedViewData): Promise<TaskSavedView> {
    await this.simulateDelay();
    
    const newView: TaskSavedView = {
      id: `view-${Date.now()}`,
      tenantId: 'tenant-1',
      createdBy: 'user-1',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isDefault: false,
      isShared: false,
      ...data
    };
    
    this.mockSavedViews.push(newView);
    return newView;
  }

  async updateSavedView(id: string, data: UpdateTaskSavedViewData): Promise<TaskSavedView> {
    await this.simulateDelay();
    
    const index = this.mockSavedViews.findIndex(view => view.id === id);
    if (index === -1) {
      throw new Error('Saved view not found');
    }
    
    this.mockSavedViews[index] = {
      ...this.mockSavedViews[index],
      ...data,
      updatedAt: new Date().toISOString()
    };
    
    return this.mockSavedViews[index];
  }

  async deleteSavedView(id: string): Promise<void> {
    await this.simulateDelay();
    
    this.mockSavedViews = this.mockSavedViews.filter(view => view.id !== id);
  }

  async setDefaultView(id: string): Promise<void> {
    await this.simulateDelay();
    
    // Remove default from all views
    this.mockSavedViews.forEach(view => {
      view.isDefault = false;
    });
    
    // Set new default
    const view = this.mockSavedViews.find(view => view.id === id);
    if (view) {
      view.isDefault = true;
    }
  }

  async getDefaultView(): Promise<TaskSavedView | null> {
    await this.simulateDelay();
    return this.mockSavedViews.find(view => view.isDefault) || null;
  }
}

export const tasksRepository = new MockTasksRepository();