// =============================================================
// Ria Living Systems â€” Unified Prisma Schema (PostgreSQL)
// Multi-tenant; clean relations; generic linking/tagging;
// RBAC, Notifications/Activity; Files; Messaging; Tasks; Library;
// FTS-ready columns (manual SQL indexes below).
///////////////////////////////////////////////////////////////

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -------------------- Enums --------------------

enum RoleName {
  super_admin
  admin
  moderator
  member
  guest
  client
}

enum PermissionAction {
  read
  write
  update
  delete
  admin
}

enum LinkKind {
  references
  duplicates
  relates
  depends_on
  blocked_by
}

enum DocKind {
  wiki
  spec
  policy
  howto
  memo
  brief
}

enum DocStatus {
  draft
  review
  scheduled
  published
  archived
}

enum PublishScope {
  private
  users
  groups
  internal
  clients
  public
}

enum TaskStatus {
  todo
  doing
  review
  blocked
  done
  canceled
}

enum TaskPriority {
  low
  medium
  high
  urgent
}

enum MessageChannelKind {
  email
  chat
  social
  sms
  internal
}

// -------------------- Core Tenancy & Users --------------------

model Tenant {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships      Membership[]
  groups           Group[]
  roles            Role[]
  membershipGroups MembershipGroup[]
  permissionGrants PermissionGrant[]
  taggings         Tagging[]
  entityLinks      EntityLink[]
  fileAssets       FileAsset[]
  attachments      Attachment[]
  messageChannels  MessageChannel[]
  threads          Thread[]
  messages         Message[]
  tasks            Task[]
  taskComments     TaskComment[]
  libraryDocs      LibraryDoc[]
  librarySections  LibrarySection[]
  docSectionLinks  DocSectionLink[]
  docPublishes     DocPublish[]
  notifications    Notification[]
  watches          Watch[]
  activityEvents   ActivityEvent[]
  searchIndexes    SearchIndex[]

  // generic helpers
  tags Tag[]
}

model User {
  id          String   @id @default(uuid()) @db.Uuid
  email       String   @unique
  displayName String
  avatarUrl   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  memberships   Membership[]
  notifications Notification[]  @relation("UserNotifications")
  activities    ActivityEvent[] @relation("UserActivities")
  watches       Watch[]

  @@index([email])
}

model Membership {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  userId    String   @db.Uuid
  roleId    String?  @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role?  @relation(fields: [roleId], references: [id])

  groups MembershipGroup[]

  @@unique([tenantId, userId])
  @@index([tenantId])
}

model Group {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  slug      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members MembershipGroup[]

  @@unique([tenantId, slug])
  @@index([tenantId, name])
}

model MembershipGroup {
  id           String   @id @default(uuid()) @db.Uuid
  tenantId     String   @db.Uuid
  membershipId String   @db.Uuid
  groupId      String   @db.Uuid
  createdAt    DateTime @default(now())

  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  membership Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  group      Group      @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([membershipId, groupId])
  @@index([tenantId, groupId])
}

model Role {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  name      RoleName
  label     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant      Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  memberships Membership[]
  grants      PermissionGrant[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

// Resource-oriented permissions (flexible for any module)
model PermissionGrant {
  id        String           @id @default(uuid()) @db.Uuid
  tenantId  String           @db.Uuid
  roleId    String           @db.Uuid
  resource  String // e.g. "task", "doc", "thread", "finance.invoice", "admin.users"
  action    PermissionAction // read|write|update|delete|admin
  condition Json? // optional JSON rule (e.g., {"own": true})
  createdAt DateTime         @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([roleId, resource, action])
  @@index([tenantId, resource, action])
}

// -------------------- Tags (generic) --------------------

model Tag {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  label     String
  color     String? // hex token from theme
  createdAt DateTime @default(now())

  tenant Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  uses   Tagging[]

  @@unique([tenantId, label])
  @@index([tenantId])
}

// Generic tagging for any entity
model Tagging {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  tagId      String   @db.Uuid
  entityType String // "task" | "doc" | "thread" | "file" | etc.
  entityId   String   @db.Uuid
  createdAt  DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([tenantId, tagId, entityType, entityId])
  @@index([tenantId, entityType, entityId])
}

// -------------------- Cross-entity Linking --------------------

model EntityLink {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  fromType  String
  fromId    String   @db.Uuid
  toType    String
  toId      String   @db.Uuid
  kind      LinkKind @default(relates)
  note      String?
  createdBy String   @db.Uuid
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, fromType, fromId])
  @@index([tenantId, toType, toId])
  @@index([tenantId, kind])
}

// -------------------- Files & Attachments --------------------

model FileAsset {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  bucket     String
  objectKey  String
  mimeType   String
  sizeBytes  Int
  sha256     String?
  uploaderId String?  @db.Uuid
  createdAt  DateTime @default(now())

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  attachments Attachment[]

  @@index([tenantId, createdAt])
  @@index([tenantId, objectKey])
}

model Attachment {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  fileId     String   @db.Uuid
  entityType String // "task" | "thread" | "doc" | ...
  entityId   String   @db.Uuid
  createdAt  DateTime @default(now())

  tenant Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  file   FileAsset @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@index([tenantId, entityType, entityId])
}

// -------------------- Messaging --------------------

model MessageChannel {
  id        String             @id @default(uuid()) @db.Uuid
  tenantId  String             @db.Uuid
  kind      MessageChannelKind
  name      String
  address   String? // inbox email, phone number, handle, etc.
  createdAt DateTime           @default(now())

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  threads Thread[]

  @@unique([tenantId, kind, address])
  @@index([tenantId, kind])
}

model Thread {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  channelId  String   @db.Uuid
  subject    String?
  status     String   @default("open") // open | snoozed | closed
  priority   String   @default("normal") // normal | high
  assigneeId String?  @db.Uuid
  labels     String[] @db.Text
  lastAt     DateTime @default(now())
  createdAt  DateTime @default(now())

  tenant   Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  channel  MessageChannel @relation(fields: [channelId], references: [id])
  messages Message[]

  @@index([tenantId, lastAt])
  @@index([tenantId, status])
  @@index([tenantId, assigneeId])
  @@index([tenantId], map: "thread_tenant_idx")
}

model Message {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  threadId   String   @db.Uuid
  authorId   String?  @db.Uuid // nullable for external senders
  authorAddr String?
  bodyText   String
  bodyMd     String?
  sentAt     DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  thread Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([tenantId, threadId, sentAt])
}

// -------------------- Tasks --------------------

model Task {
  id          String       @id @default(uuid()) @db.Uuid
  tenantId    String       @db.Uuid
  number      Int // human-friendly incremental per-tenant (handle in app/tx)
  title       String
  description String?
  status      TaskStatus   @default(todo)
  priority    TaskPriority @default(medium)
  assigneeIds String[]     @db.Text
  labels      String[]     @db.Text
  dueAt       DateTime?
  createdBy   String?      @db.Uuid
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?

  tenant   Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  comments TaskComment[]

  @@unique([tenantId, number])
  @@index([tenantId, status, priority])
  @@index([tenantId, updatedAt])
  @@index([tenantId, dueAt])
}

model TaskComment {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  taskId    String   @db.Uuid
  authorId  String?  @db.Uuid
  bodyMd    String
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([tenantId, taskId, createdAt])
}

// -------------------- Library (Wiki/Docs) --------------------

model LibraryDoc {
  id        String    @id @default(uuid()) @db.Uuid
  tenantId  String    @db.Uuid
  title     String
  slug      String?
  kind      DocKind   @default(wiki)
  status    DocStatus @default(draft)
  ownerId   String?   @db.Uuid
  tags      String[]  @db.Text
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  bodyMd     String?
  bodyTypist Json?

  sections  DocSectionLink[]
  publishes DocPublish[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, slug])
  @@index([tenantId, status])
  @@index([tenantId, kind])
  @@index([tenantId, updatedAt])
  @@map("library_docs")
}

model LibrarySection {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  name       String
  bodyMd     String?
  bodyTypist Json?
  version    Int      @default(1)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  usedBy DocSectionLink[]
  tenant Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, name, version])
  @@index([tenantId, name])
  @@map("library_sections")
}

model DocSectionLink {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  docId     String   @db.Uuid
  sectionId String   @db.Uuid
  position  Int      @default(0)
  params    Json?
  createdAt DateTime @default(now())

  doc     LibraryDoc     @relation(fields: [docId], references: [id], onDelete: Cascade)
  section LibrarySection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  tenant  Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, docId, position])
  @@map("doc_section_links")
}

model DocPublish {
  id        String       @id @default(uuid()) @db.Uuid
  tenantId  String       @db.Uuid
  docId     String       @db.Uuid
  scope     PublishScope
  userIds   String[]     @db.Text
  groupIds  String[]     @db.Text
  urlPath   String?
  createdAt DateTime     @default(now())

  doc    LibraryDoc @relation(fields: [docId], references: [id], onDelete: Cascade)
  tenant Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, scope])
  @@map("doc_publishes")
}

// -------------------- Notifications & Activity --------------------

model Notification {
  id         String    @id @default(uuid()) @db.Uuid
  tenantId   String    @db.Uuid
  userId     String    @db.Uuid
  entityType String
  entityId   String    @db.Uuid
  kind       String // "assigned","mentioned","linked","status_changed",...
  payload    Json?
  readAt     DateTime?
  createdAt  DateTime  @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId, userId, createdAt])
  @@index([tenantId, entityType, entityId])
}

model Watch {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  userId     String   @db.Uuid
  entityType String
  entityId   String   @db.Uuid
  createdAt  DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId, entityType, entityId])
  @@index([tenantId, entityType, entityId])
}

model ActivityEvent {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  actorId    String?  @db.Uuid
  entityType String
  entityId   String   @db.Uuid
  action     String // "create","update","link","comment","publish"...
  meta       Json?
  createdAt  DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actor  User?  @relation("UserActivities", fields: [actorId], references: [id])

  @@index([tenantId, entityType, entityId, createdAt])
}

// -------------------- Search (FTS-ready) --------------------
// NOTE: Prisma does not natively support tsvector columns; you can add them
// via SQL migrations. Optionally create a separate SearchIndex table or
// use generated columns on key entities. Provided here is a generic index
// table pattern.

model SearchIndex {
  id         String   @id @default(uuid()) @db.Uuid
  tenantId   String   @db.Uuid
  entityType String // "task","doc","thread"
  entityId   String   @db.Uuid
  // denormalized text used for search previews
  title      String?
  snippet    String?
  // raw text blob to index (app or trigger maintains)
  content    String
  // When using FTS, create a tsvector column via SQL and a GIN index
  // searchVec Unsupported("tsvector")?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, entityType, entityId])
  @@index([tenantId, updatedAt])
}
